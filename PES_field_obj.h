////////////////////////////////////////////////////////
//                        PES                         //
//         written by: Wronsky & Edi Edison           //
////////////////////////////////////////////////////////

/*
     FIELD OBJECTS
Here we define the objects of the field.
We also implement the electric and magnetic functions of each object

Usually included from PES_arena.h
*/



#ifndef FIELD_OBJ
#define FIELD_OBJ 

#include "PES_EM_structs.h"


//////////////ENUM
enum PES_OBJ_NAMES
{
 //playing objects
 DISK,
 PLAYER_TYPE,

 //electromagnetic objects
 POINT_CHARGE,
 COIL,
 SOLENOID,
 WIRE,

 //goals
 RECT_GOAL,
 BUMPER
};


enum PES_EVENT_TYPE
{
 GOAL_RECT,
 WALL_COLLISION,
 DISK_COLLISION,
 PLAYER_COLLISION,
 BUMPER_COLLISION

};


////////////CLASSES
class PES_field_obj 
{

 public:
  //constructor
  PES_field_obj(PES_vector2d input_pos = 0): pos(input_pos) {};

  //SET functions
  void set_pos_x(PES_FLOAT input_pos_x) {pos.x = input_pos_x;};
  void set_pos_y(PES_FLOAT input_pos_y) {pos.y = input_pos_y;};
  void set_pos(const PES_vector2d& input_pos) {pos = input_pos;};
  void set_pos(std::istringstream&);


  //it is suggested only to use get_pos
  PES_vector2d get_pos()   {return pos;};
  PES_FLOAT get_x()        {return pos.x;};
  PES_FLOAT get_y()        {return pos.y;};

  PES_INT get_image()     {return image_name;};
  
  //integer index for the texture in the relative texture vector (which depends on obj type)
  //the vector is stored in PES_arena
  PES_INT image_name;
 

 private:

  PES_vector2d pos;
 
};


//first distinction: moving and non-moving obj
class PES_mov_obj: public PES_field_obj 
{

 public:
  void set_vel_x(PES_FLOAT input_vel_x) {vel.x = input_vel_x;};
  void set_vel_y(PES_FLOAT input_vel_y) {vel.y = input_vel_y;};
  void set_vel(const PES_vector2d& input_vel) {vel = input_vel;};
  void set_vel(std::istringstream&);

  PES_vector2d get_vel() {return vel;};
  PES_FLOAT get_vel_x()  {return vel.x;};
  PES_FLOAT get_vel_y()  {return vel.y;};

 private:
  PES_vector2d vel;

};


class PES_still_obj: public PES_field_obj
{

};


///////////////////// electromagnetic objects ////////////////////////

//get_elctric/magnetic_field returns the field generated by the obj in the target

//object with both magnetic and electric properties
class PES_EM_obj: public PES_still_obj
{
 public:

  PES_EL_field get_electric_field(PES_vector2d target);  
  PES_MG_field get_magnetic_field(PES_vector2d target);

 private:
  
};


class PES_EL_obj: public PES_still_obj
{
 public:
  PES_EL_field get_electric_field(PES_vector2d);

 private:

};


class PES_MG_obj: public PES_still_obj
{
 public:
  PES_EL_field get_magnetic_field(PES_vector2d);

 private:

};


//////////////////// usable objects //////////////////////////////////

class PES_point_charge: public PES_EL_obj
{
 public:
 //constructor
 PES_point_charge (const std::string);

 //public functions
 void set_charge(PES_EM_TYPE input_charge) {charge = input_charge;};
 PES_EL_field  get_electric_field (PES_vector2d, PES_FLOAT);  //the PES_FLOAT argument is the table height
 
 private:
 PES_EM_TYPE charge;

};


//PES_solenoid generates a z-axis oriented uniform magnetic field in a circular region
class PES_solenoid: public PES_MG_obj
{
 public:
 //constructor
 PES_solenoid(const std::string);

 //public functions
 PES_MG_field  get_magnetic_field(PES_vector2d);
 PES_FLOAT     get_radius() {return radius;};

 private:
 PES_FLOAT radius;
 PES_EM_TYPE current;
 PES_INT n_coils;
};


//PES_coil is a magnetic dipole oriented along the z axis
class PES_coil: public PES_MG_obj
{
 public:
 //constructor
 PES_coil(PES_vector2d, PES_FLOAT);
 PES_coil(const std::string);

 //public functions
 PES_MG_field  get_magnetic_field(PES_vector2d, PES_FLOAT);  //the PES_FLOAT argument is the table height

 private:
 PES_FLOAT mag_dipole;

};


//PES_wire is a wire with uniform linear charge density transverse to the playing field
//it is an electric object, not a wire with current I (which wouldn't generate a z 
//magnetic component)
class PES_wire: public PES_EL_obj
{
 //constructor
 public:
 PES_wire(const std::string);

 //public functions
 PES_EL_field  get_electric_field(PES_vector2d);

 private:
 PES_FLOAT linear_charge;

};


/////////////////////////// DISK ///////////////////////////////////////
//the playing "ball"
class PES_disk: public PES_mov_obj
{
 public:
  
  PES_disk(const std::string);
  // get and set methods
  PES_EM_TYPE get_charge()    {return charge;};
  PES_EM_TYPE get_magdipole() {return magdipole;};
  
  PES_INT       get_goal_score() {return goal_score;};
  PES_MASS_TYPE get_mass()       {return mass;}; 
  PES_FLOAT     get_radius()     {return radius;};

  void set_charge     (PES_EM_TYPE input_charge) {charge = input_charge;};
  void set_magdipole  (PES_EM_TYPE input_dipole) {magdipole = input_dipole;}; //not implemented yet :(
 
 private:  
  
  //physic stats
  PES_EM_TYPE charge, magdipole;
  PES_MASS_TYPE mass;
  PES_FLOAT radius;

  //game stats (actually, a score multiplier for the goal score)
  PES_INT goal_score;

};



//ENUM cout (used in error messages)
inline std::ostream& operator << (std::ostream& os, PES_OBJ_NAMES name)
{
 switch(name)
 {
  case DISK:           os << "disk";               break;
  case PLAYER_TYPE:    os << "player";             break;
  case POINT_CHARGE:   os << "point charge";       break;
  case COIL:           os << "coil";               break;
  case SOLENOID:       os << "solenoid";           break;
  case WIRE:           os << "wire";               break;
  case BUMPER:         os << "bumper";             break;
  case RECT_GOAL:      os << "rect_goal";          break;

  default:             os << "undefined object";   break;
 }

 return os;
};




#endif





















